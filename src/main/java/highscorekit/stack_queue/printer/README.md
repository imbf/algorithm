## 프린터 (스택/큐)
일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 
이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 
이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.

> 1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
> 2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
> 3. 그렇지 않으면 J를 인쇄합니다.

## 풀이 과정
**나의 풀이**
1. priority와 현재 location을 저장할 수 있는 Document 객체를 만든다.
2. priorities와 location를 모두 Document 객체로 추상화 시켜 Queue에 넣는다.
3. Queue에서 원소를 하나 꺼내 원소를 꺼낸 후의 Queue의 최대 값과 비교한다.
    - 원소가 Queue의 최대값 보다 크다면 order를 증가시킨다.
    - 원소가 Queue의 최대값 보다 작다면 Queue의 맨 뒤에 넣는다.
4. 모든 작업이 끝난 후의 Order를 구하면 된다.

**가장 인기 많은 풀이**
1. 우선순위를 저장할 수 있는 Queue를 만들고 Priorities를 저장한다.
2. Priorities를 우선순위 순서로 오름차순 정렬한다.
3. Queue의 원소를 하나씩 가져온다.
    - Queue의 원소가 최대값이면 answer의 값은 하나 증가하고 우리가 탐색하ㅎ려는 원소의 인덱스는 하나씩 감소한다. 탐색하려는 원소의 위치가 0이하가 되면 break;
    - Queue의 원소가 최대값이 아니면 다시 Queue의 Tail에 해당 원소를 넣고 탐색하려는 원소의 인덱스를 조정해준다.
4. 이러한 방법을 통해서 탐색하려는 원소가 Queue의 head에 존재하고 최대값이라면 l은 -1이 될 것이고 이 떄에 answer가 정답이다.

## 이 문제를 풀면서 새로 알게된 사실
- IntStream의 max 메소드는 OptionalInt 객체를 리턴하기 때문에 스트림에 원소가 없을 때를 고려해서 orElseGet(IntSupplier other)를 사용해 primitive int를 리턴받자.
- 내가 푼 것 만이 답이 아니니 꼭 다른사람들의 풀이를 하나씩 참고해보자!! 이는 실력 향상의 지름길이다.



